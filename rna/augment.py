"""
Both functions to augment data and to manipulate augmented data.
"""

import numpy as np

from rna.utils import AugmentedData
from rna.analytics import combine_samples


def construct_random_samples(X, y, n, classes_to_include, n_features, binarize):
    """
    Returns n generated samples that contain classes classes_to_include. A sample is generated by random sampling a
    sample for each class, and adding the shuffled replicates.

    :param X: N_single_cell_experimental_samples array and within a list filled with for each
        n_single_cell_experimental_sample a N_measurements per sample x N_markers array
    :param y: list of length N_single_cell_experimental_samples filled with int labels of which cell type was measured
    :param n: number of samples to generate
    :param classes_to_include: iterable of int, cell type indices to include in the mixtures
    :param n_features: int: N_markers (=N_features)
    :param binarize: bool: if True transform samples into binary samples with threshold 150
    :return: n x n_features array
    """

    if len(classes_to_include) == 0:
        return np.zeros((n, n_features))
    data_for_class=[]
    for clas in classes_to_include:
        data_for_class.append(X[np.argwhere(np.array(y) == clas)[:, 0]])

    augmented_samples = []
    for i in range(n):
        sampled = []
        for j, clas in enumerate(classes_to_include):

            n_in_class = sum(np.array(y) == clas)
            sampled_sample = data_for_class[j][np.random.randint(n_in_class)[0]]
            n_replicates = len(sampled_sample)
            sampled.append(sampled_sample[np.random.permutation(n_replicates)])
        # TODO thus lower replicates for more cell types. is this an issue?
        smallest_replicates = min([len(sample) for sample in sampled])

        combined_sample = []
        for i_replicate in range(smallest_replicates):
            combined_sample.append(np.max(np.array([sample[i_replicate] for sample in sampled]), axis=0))

        augmented_samples.append(np.array(combined_sample))

    combined_samples = binarize_and_combine_samples(augmented_samples, binarize)

    return combined_samples


def binarize_and_combine_samples(augmented_samples, binarize):
    if binarize:
        augmented_samples_bin = [
            np.where(augmented_samples[i] > 150, 1, 0) for i in
            range(len(augmented_samples))]
        combined_samples = combine_samples(augmented_samples_bin)
    else:
        combined_samples = combine_samples(augmented_samples)
    return combined_samples


def only_use_same_combinations_as_in_mixtures(X_augmented, y_nhot, y_nhot_mixtures):
    """
    Make sure that the combinations of cell types present in the mixtures dataset is the same in the augmented test
    dataset.
    """

    unique_mixture_combinations = np.unique(y_nhot_mixtures, axis=0)
    indices = [np.argwhere(np.all(y_nhot == unique_mixture_combinations[i, :], axis=1)).tolist() for i in range(unique_mixture_combinations.shape[0])]
    indices_flatter = [val for sublist in indices for val in sublist]
    indices_flattened = [val for sublist in indices_flatter for val in sublist]

    X_as_mixt = X_augmented[indices_flattened, :]
    y_nhot_as_mixt = y_nhot[indices_flattened, :]

    if X_as_mixt.shape[0] == 0:
        # when there is not a single match between the y_nhot and y_nhot_mixtures
        X_as_mixt = np.zeros([1, X_as_mixt.shape[1]])
        y_nhot_as_mixt = np.zeros([1, y_nhot_as_mixt.shape[1]])

    return X_as_mixt, y_nhot_as_mixt


def augment_data( X, y, n_celltypes, n_features, n_samples, label_encoder, prior=None, binarize=False):
    """
    Generate data for the power set of single cell types.

    :param X: n_samples x n_measurements per sample x n_markers array of measurements
    :param y: list of length N_single_cell_experimental_samples filled with int labels of which cell type was measured
    :param n_celltypes: int: number of single cell types
    :param n_features: int: n_markers
    :param n_samples: number of augmented samples to generate
    :param label_encoder: encoder that encodes labels with value between 0 and n_cell types-1
    :param prior: list of length n_celltypes representing the priors for the single cell types
    :param binarize: bool: if True transform samples into binary samples with threshold 150 and if False keep the
        original signal values but normalize (/1000).
    :return: n_samples x n_markers array,
             n_samples x n_celltypes matrix of 0, 1 indicating for each augmented sample which single cell type it
                was made up of.
    """
    if prior is None: # uniform priors, exception for penile skin (should be coded more generally!)
        prior = [0.5] * n_celltypes

    assert len(prior) == n_celltypes, "Not all cell types are given a prior value" \
                                      "Make sure the length of the list(s) in 'prior' in settings is equal to" \
                                      "the number of cell types."


    if X.size == 0:
        # This is the case when calibration_size = 0.0, this is an implicit way to
        # ensure that calibration is not performed.
        X_augmented=None
        y_nhot_augmented=np.zeros((0, n_celltypes))

    else:
        X_augmented = np.zeros((n_samples, n_features))
        y_nhot_augmented = np.zeros((n_samples, n_celltypes), dtype=int)

        begin = 0
        for i in range(n_samples):
            rand = np.random.rand(n_celltypes, 1)

            # figure out which classes will be in the combination each iteration
            classes_in_current_mixture = []
            for i_celltype in range(n_celltypes):
                if rand[i_celltype] < prior [i_celltype]:
                    classes_in_current_mixture.append(i_celltype)
                    y_nhot_augmented[i, i_celltype] = 1

            X_augmented = np.append(X_augmented,
                                    construct_random_samples(X, y, 1, classes_in_current_mixture, n_features,
                                                             binarize=binarize), axis=0)
        if not binarize:
            X_augmented = X_augmented / 1000

    return X_augmented, y_nhot_augmented[:, :n_celltypes]


def augment_splitted_data(X_train, y_train, X_calib, y_calib, X_test, y_test, y_nhot_mixtures, n_celltypes, n_features,
                          label_encoder, prior, binarize, nsamples) -> AugmentedData:
    """
    Creates augmented samples for train, calibration and test data and saves it within a class.
    NB priors are always uniform for test data

    :param X_train: n_train_samples x n_features array of measurements
    :param y_train: list of length n_train_samples of labels
    :param X_calib: n_calibration_samples x n_features array of measurements
    :param y_calib: list of length n_calibration_samples of labels
    :param X_test: n_test_samples x n_features array of measurements
    :param y_test: list of length n_test_samples of labels
    :param y_nhot_mixtures: n_mixture_samples x n_celltypes array of labels
    :param n_celltypes: int: number of single cell types
    :param n_features: int: N_markers (=N_features)
    :param label_encoder: encoder that encodes labels with value between 0 and n_cell types-1
    :param prior: list of length n_celltypes representing the distribution of the augmented samples
    :param binarize:  bool: if True transform samples into binary samples with threshold 150 and if False keep the
        original signal values but normalize (/1000).
    :return: class with augmented samples for train, calibration, test and test as mixtures
    """

    X_train_augmented, y_train_nhot_augmented = augment_data(X_train, y_train, n_celltypes, n_features,
                                                             nsamples[0], label_encoder, prior,
                                                             binarize=binarize)
    X_calib_augmented, y_calib_nhot_augmented = augment_data(X_calib, y_calib, n_celltypes, n_features,
                                                             nsamples[1], label_encoder, prior,
                                                             binarize=binarize)
    # use uniform priors for test data
    if not X_test is None:
        X_test_augmented, y_test_nhot_augmented = augment_data(X_test, y_test, n_celltypes, n_features,
                                                               nsamples[2], label_encoder, [1] * n_celltypes,
                                                               binarize=binarize)
        X_test_as_mixtures_augmented, y_test_as_mixtures_nhot_augmented = only_use_same_combinations_as_in_mixtures(
            X_test_augmented, y_test_nhot_augmented, y_nhot_mixtures)
        print('test:', X_test_augmented.shape)
        print('testasm:', X_test_as_mixtures_augmented.shape)
    else:
        X_test_as_mixtures_augmented=y_test_nhot_augmented=y_test_as_mixtures_nhot_augmented=None
        X_test_augmented=None

    print('train:', X_train_augmented.shape)
    print('calib:', X_calib_augmented.shape)

    class_to_return = AugmentedData(X_train_augmented, y_train_nhot_augmented, X_calib_augmented, y_calib_nhot_augmented, \
           X_test_augmented, y_test_nhot_augmented, X_test_as_mixtures_augmented, y_test_as_mixtures_nhot_augmented)


    return class_to_return


class MultiLabelEncoder():
    """
    Class that converts list of labels into nhot-encoded vectors and the other way around.

    :param n_classes: the number of single cell types
    :param nhot_of_combinations: n_unique_combinations x n_classes matrix containing all unique combinations of cell
        types.
    """

    def __init__(self, n_classes):
        self.n_classes = n_classes
        self.nhot_of_combinations = make_nhot_matrix_of_combinations(n_classes)

    def nhot_to_labels(self, y_nhot):
        """
        Transforms a nhot encoded matrix into a list of labels.
        """
        y = np.array([np.argwhere(np.all(self.nhot_of_combinations == y_nhot[i, :], axis=1)).flatten() for i in range(y_nhot.shape[0])])
        return y.ravel()

    def labels_to_nhot(self, y):
        """
        Transforms a list of labels into a nhot encoded matrix.
        """
        if len(y.shape) == 1 or y.shape[1] == 1:
            if not np.all(np.unique(y) == [0, 1]): # this when the model predicts one target class in hot encoded, but
                # it is seen as a list of labels being predicted.
                n = y.shape[0]
                # TODO: FutureWarning: arrays to stack must be passed as a "sequence" ...
                y_nhot = np.vstack(self.nhot_of_combinations[y[i], :] for i in range(n))
        return y_nhot

    def transform_single(self, y):
        """
        Transforms the MultiLabelEncoded labels into original labels of the single cell type data set.
        """
        y = y.reshape(-1, 1)
        y_transformed = np.zeros_like(y)
        for label in np.unique(y):
            y_transformed[np.argwhere(np.all(y == label, axis=1)).flatten()] = np.log2(label)

        return y_transformed

    def inv_transform_single(self, y):
        """
        Transforms the original labels of the single cell type data set into the MultiLabelEncoded labels
        """
        y_transformed = np.zeros_like(y)
        for label in np.unique(y):
            y_transformed[np.argwhere(np.all(y == label, axis=1)).flatten()] = 2 ** label

        return y_transformed


def make_nhot_matrix_of_combinations(N):
    """
    Makes nhot encoded matrix with all possible combinations of existing single cell types.

    :param N: int
    :return: 2 ** N x n_celltypes matrix nhot encoded
    """

    def int_to_binary(i):
        binary = bin(i)[2:]
        while len(binary) < N:
            binary = '0' + binary
        return np.flip([int(j) for j in binary]).tolist()

    return np.array([int_to_binary(i) for i in range(2**N)])